*题目链接*

https://leetcode-cn.com/problems/longest-common-subsequence/

*题目介绍*

最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

输入：text1 = "abcde", text2 = "ace" 

输出：3  

解释：最长公共子序列是 "ace"，它的长度为 3。


```python
class Solution:
    def longestCommonSubsequence(self, t1: str, t2: str) -> int:
        memo = {}

        def dp(i, j):
            # 查表
            if (i, j) in memo:
                return memo[(i, j)]
            # base case
            if i == -1 or j == -1:
                return 0

            if t1[i] == t2[j]:
                memo[(i, j)] = dp(i - 1, j - 1) + 1

            else:
                memo[(i, j)] = max(dp(i, j - 1), dp(i - 1, j))
            return memo[(i, j)]

        m, n = len(t1) - 1, len(t2) - 1
        return dp(m, n)
```
*思路*

首先，拿到本题，脑海里应该有一个解题大框架，你看到**子序列**就应该想到这题大概率需要用到两个指针*i，j* 分别指向字符串某个位置，然后按一定规律朝某一方向延申，还记得上次的[编辑距离](dis.md)吗？思路其实差不多，两个指针，然后不同情况直接*max*对抗

本题分为三种情况

*1.* 两个指针所指位置对应字符相等，这个很简单，说明已经找到一个了，总数即为*1 + dp(i-1,j- 1)* 

*2.* 举个例子，如*s1 = "bpd",s2 = "ebi"* 这个时候我们想象这两个都是数轴，是不是把*s2*往左边拉一个，这样两个是不是又可以相等了,就是*dp(i,j-1)*
类似的，若*s1 = "bpd",s2 = "poi"*
这个时候，把*s1*往左边拉一个就行，就是*dp(i-1,j)*

是不是轻轻松松，本题就解决了，根本不费吹灰之力，就把这题解决，这就告诉我们学算法题学的是**框架，思路**，而不是只会一道题

但是，这是最优解吗？当然不是，我们在[斐波那契数列](fibo.md)已经讲过，你重复迭代函数肯定时间复杂度高，那么我们就要想如何来重复写表来降低复杂度


```python
class Solution:
    def longestCommonSubsequence(self, t1: str, t2: str) -> int:
        m, n = len(t1), len(t2)

        # 构建DP TABLE + base case
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if t1[i - 1] == t2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[-1][-1]
```

*思路*

本题关于*dp[i][j]* 的定义是*s1[0:i],s2[0:j]*两者的最长公共序列长度，**当i,j都等于0时，自然为0，这也是为什么i,j从1开始，本质上遍历的范围还是整个字符**

本题分为三种情况

*1.* 两个指针所指位置对应字符相等，这个很简单，说明已经找到一个了，总数即为*1 + dp[i-1][j- 1]* 

*2.* 举个例子，如*s1 = "bpd",s2 = "ebi"* 这个时候我们想象这两个都是数轴，是不是把*s2*往左边拉一个，这样两个是不是又可以相等了,就是*dp[i,j-1]*
类似的，若*s1 = "bpd",s2 = "poi"*
这个时候，把*s1*往左边拉一个就行，就是*dp[i-1,j]*

*3.* 万一都不相等怎么办，它题目说要求最长，你都不相等，能是最长吗？直接舍去
***

*注意点*

一开始的列表生成就应该有人写成
```python
dp = [[0] * (n + 1)] * (m + 1)
```
然后说明明生成都一样，可结果就是报错，*python*生成一维数组这样做没问题，可如果上升到二维，它会把里面的看成一个整体，简单说来就是**你改大家改**

```python
dp = [[0] * 2] * 2
dp[0][0] = 1 
print(dp)
#[[1,0],[1,0]]
```

奇怪的是我只想改一个，结果都变了

正确生成二维数组需要这样写
```python
dp = [[0] * (n + 1) for _ in range(m + 1)]
```