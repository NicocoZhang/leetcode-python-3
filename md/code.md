*说明*
********************************
本版块是用来记录刷题中遇到的那些坑
********************************

**力扣**
********************************
**具体**

*1.* 迭代方面

因为题解是*python*类的形式，所以要迭代函数的时候需要*self*句点访问法，详见[斐波那契数列](fibo.md)

```python
return self.fib(n-1) + self.fib(n-2)
```


*2.* 值的替代

有时候习惯了***n***,题目中有时候是别的，如*amount*，写的时候容易忽略,详见[零钱兑换](coin.md)

```python
n = amount
```

*3.* 嵌套函数

有时候在题解方法(*python*类中函数称为方法)里面又套用一个函数，别忘了至少两个*return*,另外，变量要在函数外面赋值，在里面之后就没有了

******
**抽象**

***读题***一定要仔细，将题目的***意思，特例***全部嚼碎

***思考***的时候一定要记得多想几步，***方方面面都要涉及，切勿盲目武断***

***提交***前多在控制台跑一跑***特例***，确保*提交* *100%* 正确

*****

**代码**
********************************
***等于号***

经常容易写着写着就忘了，把 *==* 写成 *=*

*******
***里外之争***

*for/while loop and functions*

```python
a = []
for i in range(10):
    a.append(i)
print(a)
#[0,1,2,3,4,5,6,7,8,9]

for i in range(10):
    a = []
    a.append(i)
#[9]
```
本来是想要将*0-9*储存到一个列表里面的，但是错把 *a = []* 放到循环里面，那么后果就是每一次执行之后导致*a*都会被重置

相应地，如果是***函数结构***，尤其是我们需要不断写表去更新然后去查表的时候，如[斐波那契数列](fibo.md),那么 *memo = {}* 一定是放在整个函数体的外面，否则每次函数迭代的时候都是空的

同样的，当然还有放在循环里面还是与循环同一逻辑

还有动态规划的***return***语句，一定是所有的都已经对抗完之后再***return***的，如果放在里面，对抗一次，或者写表一次就出值，跟后面没有多大关系了

说到底，大家写代码的时候一定要搞清楚***内外逻辑***

***
***一损俱损***
```python
a = [1,2,3]
b = a
c = a.copy()
a[-1] = 2
print(b)
#[1,2,2]
print(c)
#[1,2,3]
```
如果像赋值那样处理一个列表，你会发现**一个改了其他都改了，需要用copy()**