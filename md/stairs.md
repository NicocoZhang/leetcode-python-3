*题目链接*

https://leetcode-cn.com/problems/climbing-stairs/

*题目介绍*
*******************************
爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2

输出： 2

解释： 有两种方法可以爬到楼顶。

1 阶 + 1 阶

2 阶

****************

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [9 for i in range(n + 1)]
        dp[0], dp[1] = 1, 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[-1]
```

*思路*

这个题目虽然没有显性*DP*的关键词，但是根据题目所给的操作，可以将本题分解为子问题求解的结构，跟一般的*DP*相比，**少了对抗求最值**

此题采用写表，具体解释读者可以参照[斐波那契数列](fibo.md)

****************

*总结*

很多时候我们发现它是子问题求解，是经典*DP*问题，可是我们拿它没办法。比如说这题，应该会有读者将次数和步数搞混。接下来讲一下具体*DP*写表的思路

**定义**

*dp*数组的定义是重中之重，技巧可以联想高中解析几何的思路

**问什么设什么**

本题问多少种，那 *dp[n]* 的意思就是走*n*阶台阶一共有多少种走法，同样的可以联系[最长递增子序列](sub.md)问题，说明有的时候*n*的含义根据具体题目要好好想一想
**************************************************************
**初始化数组**

一般都要求*dp[n]*,所以毫无疑问，长度为索引+*1*，具体取值看题目要求。别忘了计算**基例**在*dp*数组的值并储存
****************
**for循环范围**

需要注意的是,*DP*问题常常可以分解类似于*dp[n] = dp[n-1]+ dp[n-2]*，那么你循环的时候就不能从1开始，至少从2开始。

**原因**是你从*1*开始最后一项就会变为*dp[-1]*

一般说来，从哪开始与数组前几个值的储存是密不可分的，因为要保证起始点可以被数组种储存的值算出

****************

**初始判断的设置**

本题*n*明显规定正整数，如果不是的话，*0*进来就会导致*IndexError*,具体看题目而定，这是开头判断

若在过程中，像[零钱兑换](coin.md),若*i - coin < 0*没有必要进行下去，可以在*for*循环里直接加*if*判断，同时，也可以采用*dp[i-coin] + 1 < dp[i]* 这种写法

```python
if coin < i and dp[i-coin] + 1 < dp[i]:
   ……
```
****************
*拓展*

本题不再给出其他思路的解法，不是说该思路优化到极致，而是有的时候，那些 *beat 100%* 的解法不具模板化，是绞尽脑汁才想出来的。这种解法对你的思维提升没有什么帮助，不过让你觉得好厉害，仅此而已。

**以小见大**

这题很简单，可我还是分析得很仔细，为什么呢？以小见大，简单的题目思路不一定简单。很多时候，那些简单的题目都可以**抽象出一个框架**，而那些看似很难的题目不过是框架的堆叠而已。

就像**递归**一样，你只有把简单题目玩懂搞透，掌握基例，那么无论后面迭代多少次，你都一样轻松解决

****************
**掌握题目**

*first*

把这道题理解透彻，无论任何时候看到你都能立马复现出来

*second*

知道每一个步骤对应背后的原理，并且**尝试突破答案最优化**

*third*

将同一核心思想但具体有些不同的其他题目解决，知道每一种题目**具体细微差别**

这样才能掌握一类题目，不至于遇到新题傻眼

***Feynman : "What i can't create,i don't understand"***