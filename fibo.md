斐波那契数，通常用F(n)表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

*F(0) = 0*，*F(1) = 1*
*F(n) = F(n - 1) + F(n - 2)*，其中 *n > 1*
给你 n ，请计算 F(n) 。

示例 1：

输入：2
输出：1

解释：*F(2) = F(1) + F(0) = 1 + 0 = 1*

### 纯递归
  递归有两个基本要素：基例以及递归关系式。
  * 基例：*F(0) = 0*,*F(1) = 1*,即递归结束的地方
  * 递归关系式：*F(n) = F(n-1) + F(n- 2)*  
  ********************************  
 ```python 
def fib(n):
    #base case
    if n <= 1:
       return n
    elif n >= 2:
       return fib(n-1) + fib(n-2)
  ```
  然后根据*python*语法特性，可以缩写为一句话
  ```python
def fib(n):
    return fib(n-1) + fib(n-2) if n >= 1 else n
  ```

*F(20) = F(19)+F(18)*  

*F(19) = F(18)+F(17)*

  然后我们发现 *F(18)* 重复，即冗余结构。这样的运算时间会很大，
    
  *节点数 \* 每个子问题所需要的时间 = 时间复杂度*
   
   显而易见，这种情况下为*O(2^N)* 

纯递归的缺点就在于存在过多冗余结构。
 
**递归加记忆**，将指数级时间将为多项式级时间。

我们可以将已经出现计算好的存在一个备忘录里面，这样我们下一次计算之前，先去查一遍表就行，不需要再重新计算。

```python
memo = {}
def fib(n):
    #查表
    if n in memo:
       return memo[n]
    #base case:
    elif n <= 1:
       return n
    else:
       ans = fib(n-1) + fib(n-2)
       memo[n] = ans
       return memo[n]
```

当然，上述的备忘录既可以采用数组，同时也可以用哈希表。

另外，如果追求完美一点，可以将基例存储到备忘录里面，这样可以减少一定程度的空间复杂度。

*memo = {0:0,1:1}*

这里介绍的是由上而下的方法，当然也可以是由下而上的。虽然比纯递归好，但是时间复杂度依然很高，*leetcode*上为1500-1600ms左右。

*bottem-up-solution*
```python
def fib(n):
    memo = {0:0,1:1}
    for i in range(2,n+1):
        memo[i] = memo[i-1] + memo[i-2]
    return memo[n]
```

*for*循环的左边是因为备忘录里面已经有键0，1了，所以从2开始。然后我们最后要计算的是*memo[n]*,*i = n* 所以要为*n+1*

这个的时间复杂度会大大降低，两者看似都是查表，但是由下而上的这种不会重新迭代函数，只会不断计算表。*leetcode*数据为36ms

1